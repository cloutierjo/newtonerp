package newtonERP.orm;

import java.lang.reflect.Field;
import java.sql.ResultSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Vector;

import newtonERP.ListModule;
import newtonERP.module.Module;
import newtonERP.module.ModuleException;
import newtonERP.module.ModuleNotFoundException;
import newtonERP.orm.exceptions.OrmException;
import newtonERP.orm.sgbd.SgbdSqlite;
import newtonERP.orm.sgbd.Sgbdable;

/**
 * 
 * @author r3hallejo, r3lacasgu
 * 
 *         Basic class for the orm. It is used to put the objects in the databse
 *         using SqLite3 and its java binding. The orm will receive an entity
 *         from which the orm will perform various tasks such as generating the
 *         query and executing it obviously. Then it's gonna send the query to
 *         the SgbdSqlite class to execute it.
 * 
 *         Types for the database : Integer, Double (Number?), String, Boolean (Integer?)
 */
public class Orm
{
    private static Sgbdable sgbd = new SgbdSqlite();
    private static String tablePrefix = "Newton_";

    /**
     * Method used to do search queries done from the views to the databse. The
     * search criterias that has been passed in parameter are a list of string
     * that has been generated by the view modules
     * 
     * @param searchEntity the entity that has to be researched
     * @param searchCriteriasParam the search criterias formatted into strings
     * @return a vector of ormizable entities
     * @throws OrmException an exception that can occur in the orm
     */
    public static Vector<Ormizable> select(Ormizable searchEntity,
	    Vector<String> searchCriteriasParam) throws OrmException
    {
	String sqlQuery = "SELECT * FROM " + tablePrefix
		+ searchEntity.getClass().getSimpleName();

	if (searchCriteriasParam != null)
	    sqlQuery = buildWhereClauseForQuery(sqlQuery, searchCriteriasParam);

	// TODO: Remove the next line when it will be properly debugged
	System.out.println("SQL query produced : " + sqlQuery);

	ResultSet rs = sgbd.execute(sqlQuery, OrmActions.SEARCH);

	return EntityCreator.createEntitiesFromResultSet(rs, searchEntity);
    }

    /**
     * Method used to insert an entity in the databse based into the entity
     * passed in parameter
     * 
     * @param newEntity the entity to be inserted
     * @throws OrmException an exception that can occur into the orm
     */
    @SuppressWarnings("unchecked")
    public static void insert(Ormizable newEntity) throws OrmException
    {
	Hashtable<String, String> data = newEntity.getOrmizableData();
	String sqlQuery = "INSERT INTO " + tablePrefix
		+ newEntity.getClass().getSimpleName() + " (";

	// We now iterate through the key set so we can add the fields to the
	// query
	Iterator keySetIterator = data.keySet().iterator();
	while (keySetIterator.hasNext())
	{
	    // Retrieve key
	    Object key = keySetIterator.next();

	    // If it's the end or not we add the key to the query with the right
	    // string ("," or not)
	    if (!keySetIterator.hasNext())
		sqlQuery += "'" + key.toString() + "') ";
	    else
		sqlQuery += "'" + key.toString() + "', ";
	}

	sqlQuery += "VALUES (";

	// Now we add the values to the query
	Iterator valueIterator = data.values().iterator();
	while (valueIterator.hasNext())
	{
	    // Retrieve value
	    Object value = valueIterator.next();

	    // If it's the end or not we add the key to the query with the right
	    // string ("," or not)
	    if (!valueIterator.hasNext())
		sqlQuery += "'" + value.toString() + "') ";
	    else
		sqlQuery += "'" + value.toString() + "', ";
	}

	// TODO: Remove the next line once this will be properly debugged
	System.out.println("SQL query produced : " + sqlQuery);

	sgbd.execute(sqlQuery, OrmActions.INSERT);
    }

    /**
     * Method used to delete an entity from the database
     * 
     * @param searchEntity the entity to be researched
     * @param searchCriterias the search criterias for the where clause
     * @throws OrmException an exception that can occur into the orm
     */
    public static void delete(Ormizable searchEntity,
	    Vector<String> searchCriterias) throws OrmException
    {
	String sqlQuery = "DELETE FROM " + tablePrefix
		+ searchEntity.getClass().getSimpleName();

	sqlQuery = buildWhereClauseForQuery(sqlQuery, searchCriterias);

	// TODO: Remove the next line once this will be properly debugged
	System.out.println("Sql query produced : " + sqlQuery);

	sgbd.execute(sqlQuery, OrmActions.DELETE);
    }

    /**
     * Method used to update / change an entity
     * 
     * @param entityContainingChanges the entity that has been changed and will
     *            be in the orm
     * @param searchCriterias the criterias used by the update
     * @throws OrmException an exception that can occur into the orm
     */
    public static void update(Ormizable entityContainingChanges,
	    Vector<String> searchCriterias) throws OrmException
    {
	String sqlQuery = "UPDATE " + tablePrefix
		+ entityContainingChanges.getClass().getSimpleName() + " SET ";
	Hashtable<String, String> data = entityContainingChanges
		.getOrmizableData();

	sqlQuery = buildSetClauseForQuery(data, sqlQuery);
	sqlQuery = buildWhereClauseForQuery(sqlQuery, searchCriterias);

	// TODO: Remove this once it will be properly debugged
	System.out.println("Sql query produced : " + sqlQuery);

	sgbd.execute(sqlQuery, OrmActions.UPDATE);
    }

    /**
     * Method used to build the where clause for the delete, select and update
     * methods
     * 
     * @param sqlQuery the non-finished sqlQuery that has been produced
     * @param searchCriterias the parameters of the where clause
     * @return sqlQuery the sqlQuery with the where statement
     */
    private static String buildWhereClauseForQuery(String sqlQuery,
	    Vector<String> searchCriterias)
    {
	sqlQuery += " WHERE ";

	// We add each string to the sqlQuery
	for (String parameter : searchCriterias)
	    sqlQuery += parameter;

	return sqlQuery;
    }

    /**
     * Method used internally by the update method to build the set statement
     * 
     * @param data
     * @param sqlQuery
     * @return sqlQuery the sqlQuery with the set statement
     */
    @SuppressWarnings("unchecked")
    private static String buildSetClauseForQuery(
	    Hashtable<String, String> data, String sqlQuery)
    {
	// We iterate through the entity containing changes to build the SET
	// statement
	Iterator keySetIterator = data.keySet().iterator();

	while (keySetIterator.hasNext())
	{
	    // Retrieve key
	    Object key = keySetIterator.next();

	    // If it's the end or not we add the key to the query with the right
	    // string ("," or not)
	    if (keySetIterator.hasNext())
		sqlQuery += key.toString() + "='" + data.get(key) + "', ";
	    else
		sqlQuery += key.toString() + "='" + data.get(key) + "'";
	}

	return sqlQuery;
    }

    /**
     * Creates the non-existent table from the modules in the database
     */
    public static void createNonExistentTables()
    {
	Hashtable<String, String> modules = ListModule.getAllModules();

	// For each module
	for (String key : modules.keySet())
	{
	    try
	    {
		Module module = ListModule.getModule(key);
		Vector<Ormizable> moduleEntities = module
			.getDefinitionEntityList();

		// For each entity in the list of module entities
		for (Ormizable entity : moduleEntities)
		{
		    // Be sure to create the table only if it doesn't already exists
		    String sqlQuery = "CREATE TABLE IF NOT EXISTS ";
		    Field[] fields = entity.getClass().getDeclaredFields();

		    sqlQuery += tablePrefix + entity.getClass().getSimpleName()
			    + " ( ";

		    // For each field into my entity
		    for (int i = 0; i < fields.length; i++)
		    {
			// If it is a primary because it matches PK, else we check the datatypes and match them with a datatype good for the database
			if (fields[i].getName().matches("PK.*"))
			{
			    if (i + 1 != fields.length)
				sqlQuery += fields[i].getName()
					+ " INTEGER PRIMARY KEY AUTOINCREMENT, ";
			    else
				sqlQuery += fields[i].getName()
					+ " INTEGER PRIMARY KEY AUTOINCREMENT);";
			}
			else if (fields[i].getType().equals(Double.class))
			{
			    if (i + 1 != fields.length)
				sqlQuery += fields[i].getName()
					+ " DOUBLE PRECISION, ";
			    else
				sqlQuery += fields[i].getName()
					+ " DOUBLE PRECISION );";
			}
			else if (fields[i].getType().equals(String.class))
			{
			    if (i + 1 != fields.length)
				sqlQuery += fields[i].getName() + " STRING, ";
			    else
				sqlQuery += fields[i].getName() + " STRING );";
			}
			else if (fields[i].getType().equals(Boolean.class))
			{
			    if (i + 1 != fields.length)
				sqlQuery += fields[i].getName() + " INTEGER, ";
			    else
				sqlQuery += fields[i].getName() + " INTEGER );";
			}
			else if (fields[i].getType().equals(int.class))
			{
			    if (i + 1 != fields.length)
				sqlQuery += fields[i].getName() + " INTEGER, ";
			    else
				sqlQuery += fields[i].getName() + " INTEGER );";
			}
		    }
		    System.out.println("Sql query produced : " + sqlQuery);
		    sqlQuery = "";
		}
	    } catch (ModuleException e)
	    {
		e.printStackTrace();
	    }
	}
    }

    /**
     * Used to initialize the connection
     * 
     * @throws OrmException an exception that can occur in the orm
     */
    public static void connect() throws OrmException
    {
	sgbd.connect();
    }

    /**
     * Used to disconnect from the db
     * 
     * @throws OrmException an exception that can occur in the orm
     */
    public static void disconnect() throws OrmException
    {
	sgbd.disconnect();
    }
}
