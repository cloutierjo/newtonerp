class SgbdSqlite
!!!222988.java!!!	execute(in request : String, inout action : OrmActions) : ResultSet
		try
		{
			Statement stat = connexion.createStatement();

			if (action.equals(OrmActions.SEARCH))
			{
				ResultSet rs = stat.executeQuery(request);
				return rs;
			}

			stat.execute(request);
			return stat.getGeneratedKeys();

		} catch (SQLException e)
		{
			throw new OrmSqlException(
					"SqlException when executing the request. Check for entity names matching SqLite keyword could be done : "
							+ e.getMessage());
		}
!!!223116.java!!!	disconnect() : void
		try
		{
			connexion.close();
		} catch (SQLException e)
		{
			throw new OrmSqlException(
					"Error whe disconnecting from the database : "
							+ e.getMessage());
		}
!!!223244.java!!!	connect() : void
		try
		{
			Class.forName("org.sqlite.JDBC");
			connexion = DriverManager.getConnection("jdbc:sqlite:"
					+ dataBaseFileName);
		} catch (Exception e)
		{
			throw new OrmSqlException("Error connecting to the database : "
					+ e.getMessage());
		}
!!!223372.java!!!	addColumnToTable(inout entity : AbstractOrmEntity, inout field : Field) : ResultSet
		String sqlQuery = "ALTER TABLE " + prefix + entity.getSystemName()
				+ " ADD COLUMN ";

		if (field instanceof FieldDouble)
		{
			sqlQuery += " " + field.getShortName() + " DOUBLE PRECISION;";
		}
		else if (field instanceof FieldString || field instanceof FieldDateTime)
		{
			sqlQuery += " " + field.getShortName() + " STRING;";
		}
		else if (field instanceof FieldBool || field instanceof FieldInt)
		{
			sqlQuery += " " + field.getShortName() + " INTEGER;";
		}

		Logger.debug("[SGDB_SQLITE] SQL query produced : " + sqlQuery);

		return execute(sqlQuery, OrmActions.OTHER);

		// todo: mettre une valeur par defaut dans la colone ajoute
!!!223500.java!!!	select(inout searchEntity : AbstractOrmEntity, inout searchCriteriasParam : Vector<String>) : ResultSet
		String sqlQuery = "SELECT * FROM " + prefix
				+ searchEntity.getSystemName();

		if (searchCriteriasParam != null)
			sqlQuery = buildWhereClauseForQuery(sqlQuery, searchCriteriasParam);

		Logger.debug("[SGDB_SQLITE] SQL query produced : " + sqlQuery);

		ResultSet rs = execute(sqlQuery, OrmActions.SEARCH);

		return rs;
!!!223628.java!!!	buildWhereClauseForQuery(inout searchEntities : Vector<AbstractOrmEntity>) : String
		String whereClause = "";
		int entityPosition = 0;
		boolean addedCriteriaToWhereCondition = false;
		whereClause += " WHERE ";

		for (AbstractOrmEntity entity : searchEntities)
		{
			// Si les fields de
			// cette entité
			// ne contiennent que des null
			if (!entity.getFields().containsValues())
				continue;

			entityPosition += 1;
			whereClause += "( ";

			for (Field<?> field : entity.getFields().getFields())
			{
				if (field.getCalcul() == null && field.getData() != null)
				{
					whereClause += field.getShortName() + " "
							+ field.getOperator() + " '"
							+ field.getDataString(true) + "'";

					whereClause += " AND ";
				}
			}

			whereClause = whereClause.substring(0, whereClause.length() - 4);

			if (entity.getFields().getFields().size() < entityPosition)
				whereClause += " OR ";

			whereClause += ")";
			// au moins un field était
			// utilisable donc on cré
			// un where
			addedCriteriaToWhereCondition = true;
		}

		if (addedCriteriaToWhereCondition)
			return whereClause; // On retourne la clause du where car elle n'est
		// pas vide
		return "";// Sinon, aucune clause where ne doit être ajoutée
!!!223756.java!!!	buildWhereClauseForQuery(inout searchEntity : AbstractOrmEntity, in sqlQuery : String) : String
		sqlQuery += " WHERE ( ";

		for (Field<?> field : searchEntity.getFields().getFields())
		{
			if (field.getCalcul() == null && field.getData() != null)
			{
				sqlQuery += field.getShortName() + " " + field.getOperator()
						+ " '" + field.getDataString(true) + "'";

				sqlQuery += " AND ";
			}
		}

		sqlQuery = sqlQuery.substring(0, sqlQuery.length() - 4);

		return sqlQuery += ");";
!!!223884.java!!!	buildSetClauseForQuery(inout fields : Fields, in sqlQuery : String) : String
		Iterator<Field<?>> dataIterator = fields.iterator();

		while (dataIterator.hasNext())
		{
			// Retrieve key
			Field<?> data = dataIterator.next();
			if (!data.getShortName().matches("PK.*")
					&& data.getCalcul() == null && data.getData() != null)
			{
				sqlQuery += data.getShortName() + "='"
						+ data.getDataString(true) + "', ";
			}
		}

		return sqlQuery.substring(0, sqlQuery.length() - 2);
!!!224012.java!!!	buildWhereClauseForQuery(in sqlQuery : String, inout searchCriterias : Vector<String>) : String
		return sqlQuery + buildWhereClause(searchCriterias) + ";";
!!!224140.java!!!	select(inout searchEntities : Vector<AbstractOrmEntity>) : ResultSet
		String sqlQuery = "SELECT * FROM " + prefix
				+ searchEntities.get(0).getSystemName();

		if (!searchEntities.isEmpty())
			sqlQuery += buildWhereClauseForQuery(searchEntities) + ";";

		Logger.debug("[SGDB_SQLITE] SQL query produced : " + sqlQuery);

		ResultSet rs = execute(sqlQuery, OrmActions.SEARCH);

		return rs;
!!!224268.java!!!	insert(inout newEntity : AbstractOrmEntity) : int
		String sqlQuery = "INSERT INTO " + prefix + newEntity.getSystemName()
				+ "( ";

		Iterator<?> keyIterator = newEntity.getFields().iterator();

		while (keyIterator.hasNext())
		{
			Field<?> field = (Field<?>) keyIterator.next();

			if (!field.getShortName().matches("PK.*"))
			{
				if (field.getCalcul() == null && field.getData() != null)
				{
					sqlQuery += "'" + field.getShortName() + "', ";
				}
			}

		}

		sqlQuery = sqlQuery.substring(0, sqlQuery.length() - 2);
		sqlQuery += ") VALUES (";

		Iterator<?> dataIterator = newEntity.getFields().iterator();

		while (dataIterator.hasNext())
		{
			Field<?> field = (Field<?>) dataIterator.next();

			if (!field.getShortName().matches("PK.*"))
			{
				if (field.getCalcul() == null && field.getData() != null)
				{
					sqlQuery += "'" + field.getDataString(true) + "', ";
				}
			}
		}

		sqlQuery = sqlQuery.substring(0, sqlQuery.length() - 2);
		sqlQuery += ");";

		Logger.debug("[SGDB_SQLITE] SQL query produced : " + sqlQuery);

		ResultSet rs = execute(sqlQuery, OrmActions.INSERT);

		int primaryKeyValue;
		try
		{
			primaryKeyValue = rs.getInt(1);

		} catch (SQLException e)
		{
			// s'il n'y a pas de cle primaire dans cette table, on ne throw donc
			// pas cette exception
			primaryKeyValue = 0;
		}

		return primaryKeyValue;
!!!224396.java!!!	delete(inout searchEntity : AbstractOrmEntity, inout searchCriterias : Vector<String>) : void
		String sqlQuery = "DELETE FROM " + prefix
				+ searchEntity.getSystemName();

		sqlQuery = buildWhereClauseForQuery(sqlQuery, searchCriterias);

		Logger.debug("[SGDB_SQLITE] SQL query produced : " + sqlQuery);

		execute(sqlQuery, OrmActions.DELETE);
!!!224524.java!!!	delete(inout searchEntities : Vector<AbstractOrmEntity>) : void
		String sqlQuery = "DELETE FROM " + prefix
				+ searchEntities.get(0).getSystemName();

		sqlQuery += buildWhereClauseForQuery(searchEntities) + ";";

		Logger.debug("[SGDB_SQLITE] SQL query produced : " + sqlQuery);

		execute(sqlQuery, OrmActions.DELETE);
!!!224652.java!!!	update(inout entityContainingChanges : AbstractOrmEntity, inout searchCriterias : Vector<String>) : void
		String sqlQuery = "UPDATE " + prefix
				+ entityContainingChanges.getSystemName() + " SET ";

		sqlQuery = buildSetClauseForQuery(entityContainingChanges.getFields(),
				sqlQuery);
		sqlQuery = buildWhereClauseForQuery(sqlQuery, searchCriterias);

		Logger.debug("[SGDB_SQLITE] SQL query produced : " + sqlQuery);

		execute(sqlQuery, OrmActions.UPDATE);
!!!224780.java!!!	update(inout searchEntities : Vector<AbstractOrmEntity>, inout entityContainingChanges : AbstractOrmEntity) : void
		String sqlQuery = "UPDATE " + prefix
				+ entityContainingChanges.getSystemName() + " SET ";

		sqlQuery = buildSetClauseForQuery(entityContainingChanges.getFields(),
				sqlQuery);
		sqlQuery += buildWhereClauseForQuery(searchEntities) + ";";

		Logger.debug("[SGDB_SQLITE] SQL query produced : " + sqlQuery);

		execute(sqlQuery, OrmActions.UPDATE);
!!!224908.java!!!	isEntityExists(in entitySystemName : String) : boolean
		String sqlQuery = "SELECT name FROM sqlite_master where name='"
				+ prefix + entitySystemName + "';";

		Logger.debug("[SGDB_SQLITE] SQL query produced : " + sqlQuery);

		ResultSet rs = execute(sqlQuery, OrmActions.SEARCH);

		try
		{
			return rs.next();
		} catch (SQLException e)
		{
			throw new OrmSqlException("probleme ici");
		}
!!!225036.java!!!	createIndex(in entityName : String, in fieldName : String) : void
		String indexName = fieldName + "_index";
		String tableName = prefix + entityName;

		String sqlQuery = "CREATE INDEX IF NOT EXISTS " + indexName + " ON "
				+ tableName + " (" + fieldName + ");";

		Logger.debug("[SGDB_SQLITE] SQL query produced : " + sqlQuery);
		execute(sqlQuery, OrmActions.OTHER);
!!!225164.java!!!	createTableForEntity(inout entity : AbstractOrmEntity) : void
		// Be sure to create the table only if it doesn't already
		// exists
		String sqlQuery = "CREATE TABLE IF NOT EXISTS ";
		Collection<Field<?>> fields = ((AbstractEntity) entity).getFields()
				.getFields();

		sqlQuery += prefix + entity.getSystemName() + " ( ";

		// For each field into my entity
		for (Field<?> field : fields)
		{
			// If it is a primary because it matches PK, else we
			// check the datatypes and match them with a datatype
			// good for the database
			// TODO : Jo je ne comprend pas pourquoi tu fesait ca,
			// bref ca buggait car il arrivait sur le if, ce n'était
			// pas vrai alors il n'insérait aucun champs. Svp dire
			// c'est quoi tu veut faire. La je l'ai enlevé, anyway
			// ca sert a rien de faire un if avec aucun traitement
			// non?
			if (field.getCalcul() != null)
			{
				// do not do anything
			}
			else if (field.getShortName().matches("PK.*"))
			{
				sqlQuery += field.getShortName()
						+ " INTEGER PRIMARY KEY AUTOINCREMENT, ";
			}
			else if (field instanceof FieldDouble)
			{
				sqlQuery += field.getShortName() + " DOUBLE PRECISION, ";
			}
			else if (field instanceof FieldString
					|| field instanceof FieldDateTime)
			{
				sqlQuery += field.getShortName() + " STRING, ";
			}
			else if (field instanceof FieldBool || field instanceof FieldInt)
			{
				sqlQuery += field.getShortName() + " INTEGER, ";
			}
		}
		sqlQuery = sqlQuery.substring(0, sqlQuery.length() - 2) + " );";

		Logger.debug("[SGDB_SQLITE] SQL query produced : " + sqlQuery);

		execute(sqlQuery, OrmActions.CREATE);
!!!225292.java!!!	updateUnique(inout searchEntity : AbstractOrmEntity, inout entityContainingChanges : AbstractOrmEntity) : void
		String sqlQuery = "UPDATE " + prefix
				+ entityContainingChanges.getSystemName() + " SET ";

		sqlQuery = buildSetClauseForQuery(entityContainingChanges.getFields(),
				sqlQuery);
		sqlQuery = buildWhereClauseForQuery(searchEntity, sqlQuery);

		Logger.debug("[SGDB_SQLITE] SQL query produced : " + sqlQuery);

		execute(sqlQuery, OrmActions.UPDATE);
!!!225420.java!!!	select(inout searchEntity : AbstractOrmEntity, inout searchCriteriasParam : Vector<String>, in limit : int, in offset : int, in orderBy : String) : ResultSet
		String sqlQuery = "SELECT * FROM " + prefix
				+ searchEntity.getSystemName();

		if (searchCriteriasParam != null)
			sqlQuery += buildWhereClause(searchCriteriasParam);

		if (orderBy != null && orderBy.length() > 0)
			sqlQuery += " ORDER BY " + orderBy;

		sqlQuery = sqlQuery + " LIMIT " + offset + ", " + limit + ";";

		Logger.debug("[SGDB_SQLITE] SQL query produced : " + sqlQuery);

		ResultSet rs = execute(sqlQuery, OrmActions.SEARCH);

		return rs;
!!!225548.java!!!	buildWhereClause(inout searchCriteriasParam : Vector<String>) : String
		String whereClause = " WHERE ( ";

		// We add each string to the sqlQuery
		for (String parameter : searchCriteriasParam)
			whereClause += parameter + " ";

		return whereClause + " )";
!!!225676.java!!!	count(inout searchEntity : AbstractOrmEntity, inout searchParameterList : Vector<String>) : int
		// Pour une raison quelconque, la fonction COUNT de SQLite empêche la
		// transaction de se terminer
		// Alors on utilise un count fait à bras

		String sqlQuery = "SELECT " + searchEntity.getPrimaryKeyName()
				+ " FROM " + prefix + searchEntity.getSystemName();

		if (searchParameterList != null)
			sqlQuery += buildWhereClause(searchParameterList);

		sqlQuery += ";";

		Logger.debug("[SGDB_SQLITE] SQL query produced : " + sqlQuery);

		ResultSet rs = execute(sqlQuery, OrmActions.SEARCH);

		int count = 0;
		try
		{
			while (rs.next())
				count++;

		} catch (SQLException e)
		{
			throw new OrmSqlException("probleme ici");
		}
		return count;
!!!225804.java!!!	doBackup() : void
		Logger.info("Backup de la DB");
		sgbdSqliteBackupManager.doBackup(dataBaseFileName,
				BackupManager.getMaximumBackupInstanceCount());
!!!225932.java!!!	getLatestBackupTime() : long
		return sgbdSqliteBackupManager.getLatestBackupTime();
